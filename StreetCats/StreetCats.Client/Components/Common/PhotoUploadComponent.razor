@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using System.Text.Json
@inject IJSRuntime JSRuntime
@inject ILogger<PhotoUploadComponent> Logger

<div class="photo-upload-component">
    <!-- Area di Drop e Selezione File -->
    <div class="upload-area @(isDragOver ? "drag-over" : "") @(isUploading ? "uploading" : "")"
         @ondrop="OnDrop"
         @ondrop:preventDefault="true"
         @ondragover="OnDragOver"
         @ondragover:preventDefault="true" 
         @ondragenter="OnDragEnter"
         @ondragenter:preventDefault="true"
         @ondragleave="OnDragLeave"
         @onclick="TriggerFileInput">
        
        @if (string.IsNullOrEmpty(PhotoUrl) && !isUploading)
        {
            <div class="upload-placeholder">
                <svg class="upload-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                          d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="upload-text">
                    <strong>Clicca per selezionare</strong> o trascina qui la foto del gatto
                </p>
                <p class="upload-hint">PNG, JPG, WebP fino a 5MB</p>
            </div>
        }
        else if (isUploading)
        {
            <div class="upload-progress">
                <div class="spinner"></div>
                <p>Caricamento foto...</p>
                @if (uploadProgress > 0)
                {
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: @(uploadProgress)%"></div>
                    </div>
                    <p class="progress-text">@(uploadProgress)%</p>
                }
            </div>
        }
        else if (!string.IsNullOrEmpty(PhotoUrl))
        {
            <div class="photo-preview">
                <img src="@GetPhotoDisplayUrl()" alt="Foto gatto" class="preview-image" />
                <div class="photo-overlay">
                    <button type="button" class="btn-change" @onclick:stopPropagation="true" @onclick="TriggerFileInput">
                        Cambia Foto
                    </button>
                    <button type="button" class="btn-remove" @onclick:stopPropagation="true" @onclick="RemovePhoto">
                        Rimuovi
                    </button>
                </div>
            </div>
        }
    </div>

    <!-- Input File Nascosto -->
    <InputFile @ref="fileInput" 
               OnChange="OnFileSelected" 
               accept="image/*" 
               style="display: none;" />

    <!-- Messaggio di Errore -->
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-message">
            <svg class="error-icon" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
            </svg>
            @errorMessage
        </div>
    }

    <!-- Info File -->
    @if (!string.IsNullOrEmpty(fileName))
    {
        <div class="file-info">
            <small class="text-muted">
                @fileName
                @if (fileSize > 0)
                {
                    <span> • @FormatFileSize(fileSize)</span>
                }
            </small>
        </div>
    }
</div>

@code {
    [Parameter] public string? PhotoUrl { get; set; }
    [Parameter] public EventCallback<string> PhotoUrlChanged { get; set; }
    [Parameter] public EventCallback<PhotoUploadResult> OnUploadCompleted { get; set; }
    [Parameter] public EventCallback OnUploadError { get; set; }
    [Parameter] public bool IsRequired { get; set; } = false;
    [Parameter] public int MaxFileSizeMB { get; set; } = 5;
    [Parameter] public string ApiBaseUrl { get; set; } = "http://localhost:3000/api";

    private InputFile? fileInput;
    private bool isDragOver = false;
    private bool isUploading = false;
    private int uploadProgress = 0;
    private string? errorMessage;
    private string? fileName;
    private long fileSize = 0;

    private string uploadEndpoint => $"{ApiBaseUrl}/upload/images";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("StreetCatsInterop.initializePhotoUpload", DotNetObjectReference.Create(this));
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Impossibile inizializzare JavaScript interop per upload foto");
        }
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        await ProcessSelectedFile(file);
    }

    private async Task ProcessSelectedFile(IBrowserFile file)
    {
        try
        {
            ClearError();

            // Validazione file
            var validationResult = ValidateFile(file);
            if (!validationResult.IsValid)
            {
                ShowError(validationResult.ErrorMessage ?? "File non valido");
                return;
            }

            fileName = file.Name;
            fileSize = file.Size;
            isUploading = true;
            uploadProgress = 0;
            StateHasChanged();

            // Upload al backend
            var result = await UploadFileToBackend(file);

            if (result.Success)
            {
                PhotoUrl = result.PhotoUrl;
                await PhotoUrlChanged.InvokeAsync(PhotoUrl);
                await OnUploadCompleted.InvokeAsync(result);
                
                Logger.LogInformation("Foto caricata con successo: {PhotoUrl}", result.PhotoUrl);
            }
            else
            {
                ShowError(result.ErrorMessage ?? "Errore durante caricamento");
                await OnUploadError.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Errore upload foto");
            ShowError("Errore imprevisto durante caricamento");
            await OnUploadError.InvokeAsync();
        }
        finally
        {
            isUploading = false;
            uploadProgress = 0;
            StateHasChanged();
        }
    }

    private async Task<PhotoUploadResult> UploadFileToBackend(IBrowserFile file)
    {
        try
        {
            // Crea FormData usando JavaScript Interop
            var fileStream = file.OpenReadStream(maxAllowedSize: MaxFileSizeMB * 1024 * 1024);
            var buffer = new byte[file.Size];
            await fileStream.ReadAsync(buffer);

            var base64Data = Convert.ToBase64String(buffer);
            
            var uploadData = new
            {
                fileName = file.Name,
                contentType = file.ContentType,
                size = file.Size,
                data = base64Data
            };

            var response = await JSRuntime.InvokeAsync<string>("StreetCatsInterop.uploadPhotoFromBlazor", 
                uploadEndpoint, 
                uploadData,
                DotNetObjectReference.Create(this));

            var result = JsonSerializer.Deserialize<ApiResponse<PhotoUploadData>>(response, 
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (result?.Success == true && result.Data != null)
            {
                return new PhotoUploadResult
                {
                    Success = true,
                    PhotoUrl = result.Data.PhotoUrl,
                    FileName = result.Data.FileName,
                    FileSize = result.Data.Size,
                    MimeType = result.Data.MimeType
                };
            }
            else
            {
                return new PhotoUploadResult
                {
                    Success = false,
                    ErrorMessage = result?.Message ?? "Upload fallito"
                };
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Errore chiamata API upload");
            return new PhotoUploadResult
            {
                Success = false,
                ErrorMessage = ex.Message
            };
        }
    }

    [JSInvokable]
    public async Task UpdateUploadProgress(int progress)
    {
        uploadProgress = progress;
        await InvokeAsync(StateHasChanged);
    }

    private FileValidationResult ValidateFile(IBrowserFile file)
    {
        // Controllo tipo file
        if (!IsValidImageType(file.ContentType))
        {
            return new FileValidationResult(false, "Tipo file non supportato. Usa JPG, PNG o WebP.");
        }

        // Controllo dimensione
        var maxBytes = MaxFileSizeMB * 1024 * 1024;
        if (file.Size > maxBytes)
        {
            return new FileValidationResult(false, $"File troppo grande. Massimo {MaxFileSizeMB}MB consentiti.");
        }

        return new FileValidationResult(true, null);
    }

    private bool IsValidImageType(string contentType)
    {
        var validTypes = new[] { "image/jpeg", "image/jpg", "image/png", "image/webp" };
        return validTypes.Contains(contentType.ToLower());
    }

    private string GetPhotoDisplayUrl()
    {
        if (string.IsNullOrEmpty(PhotoUrl)) return "";

        // Se è un URL completo, usalo direttamente
        if (PhotoUrl.StartsWith("http"))
        {
            return PhotoUrl;
        }

        // Se è un path relativo, costruisci URL completo
        var baseUrl = ApiBaseUrl.Replace("/api", "");
        return $"{baseUrl}{PhotoUrl}";
    }

    private async Task RemovePhoto()
    {
        PhotoUrl = null;
        fileName = null;
        fileSize = 0;
        ClearError();
        
        await PhotoUrlChanged.InvokeAsync(PhotoUrl);
        StateHasChanged();
    }

    private async Task TriggerFileInput()
    {
        if (fileInput != null && !isUploading)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("StreetCatsInterop.triggerFileInput", fileInput.Element);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Impossibile attivare selezione file");
            }
        }
    }

    // Event handlers per drag & drop (Blazor non supporta preventDefault in C#)
    private void OnDragOver() 
    { 
        // Il preventDefault è gestito dall'attributo del div
    }
    
    private void OnDragEnter() 
    { 
        isDragOver = true; 
        StateHasChanged(); 
    }
    
    private void OnDragLeave() 
    { 
        isDragOver = false; 
        StateHasChanged(); 
    }

    private async Task OnDrop()
    {
        isDragOver = false;
        StateHasChanged();

        try
        {
            // Il drop è gestito via JavaScript
            await JSRuntime.InvokeVoidAsync("StreetCatsInterop.handleFileDrop", 
                DotNetObjectReference.Create(this));
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Errore gestione drop file");
        }
    }

    [JSInvokable]
    public async Task HandleDroppedFile(string fileName, string contentType, long size, string base64Data)
    {
        await Task.Run(() => {
            try
            {
                ShowError("Drag & drop non ancora implementato - usa click per selezionare file");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Errore gestione file drag & drop");
                ShowError("Errore elaborazione file trascinato");
            }
        });
    }

    private void ShowError(string message)
    {
        errorMessage = message;
        StateHasChanged();
    }

    private void ClearError()
    {
        errorMessage = null;
    }

    private string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024:F1} KB";
        return $"{bytes / (1024 * 1024):F1} MB";
    }

    // Data Models
    public class PhotoUploadResult
    {
        public bool Success { get; set; }
        public string? PhotoUrl { get; set; }
        public string? FileName { get; set; }
        public long FileSize { get; set; }
        public string? MimeType { get; set; }
        public string? ErrorMessage { get; set; }
    }

    public class PhotoUploadData
    {
        public string PhotoUrl { get; set; } = "";
        public string FileName { get; set; } = "";
        public long Size { get; set; }
        public string MimeType { get; set; } = "";
    }

    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public T? Data { get; set; }
        public string? Message { get; set; }
    }

    private record FileValidationResult(bool IsValid, string? ErrorMessage);
}